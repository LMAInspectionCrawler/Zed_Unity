//======= Copyright (c) Stereolabs Corporation, All rights reserved. ===============

using UnityEngine;
using UnityEngine.Rendering;


/// <summary>
/// Displays the image of the ZED into a quad.
/// Inserts the depth and normals inside the pipeline
/// Compute the data for the light and send them to the shaders
/// Post-processes the image
/// </summary>
[RequireComponent(typeof(Camera))]
public class ZEDRenderingPlane : MonoBehaviour
{
    /// <summary>
    /// The rendering mode accepted 
    /// </summary>
    enum ZED_RENDERING_MODE
    {
        FORWARD,
        DEFERRED,
        LAST
    };


    /// <summary>
    /// The screen is the quad where the textures are displayed
    /// </summary>
    public GameObject canvas;

    /// <summary>
    /// It's the main material, used to set the color and the depth
    /// </summary>
    private Material matRGB;

    /// <summary>
    /// All the textures displayed are in 16/9
    /// </summary>
    private float aspect = 16.0f / 9.0f;

    /// <summary>
    /// The main camera is the virtual camera controlled by the ZED
    /// </summary>
    private Camera mainCamera;

    /// <summary>
    /// The link to the ZED SDK
    /// </summary>
    private sl.ZEDCamera zedCamera;

    /// <summary>
    /// Texture generated from the ZED, it may be the from the left or right eye of the ZED
    /// </summary>
    private Texture2D textureEye;
    public Texture2D TextureEye { get { return textureEye; } }

    /// <summary>
    /// Depth generated by the ZEDCamera
    /// </summary>
    Texture2D depth;

    /// <summary>
    /// Normals generated by the ZEDCamera
    /// </summary>
    Texture2D normals;

    /// <summary>
    /// CommandBuffer to integrate the depth in the pipeline of Unity for deferred and forward
    /// </summary>
    CommandBuffer[] buffer = new CommandBuffer[(int)ZED_RENDERING_MODE.LAST];

    /// <summary>
    /// CommandBuffer to create a mask for the virtual objects in forward and deferred
    /// </summary>
    CommandBuffer[] postProcessBuffer = new CommandBuffer[(int)ZED_RENDERING_MODE.LAST];

    /// <summary>
    /// The material used to integrate the depth in forward mode after the depth texture is created, mainly use to get the shadows. Not needed for the light only
    /// </summary>
    private Material forwardMat;

    /// <summary>
    /// The material used to integrate the depth in deferred mode. Always used in deferred
    /// </summary>
    private Material deferredMat;

    /// <summary>
    /// The actual rendering path used
    /// </summary>
    private RenderingPath actualRenderingPath = RenderingPath.VertexLit;
    public RenderingPath ActualRenderingPath
    {
        get { return actualRenderingPath; }
    }
    MeshFilter meshCanvas;

    /// <summary>
    /// A Low resolution of the textures from the ZED
    /// </summary>
    private sl.Resolution resolution = new sl.Resolution(384, 192);
    /***LIGHTS definitions***/
    /// <summary>
    /// Point light structure sends to the shader via a compute buffer
    /// </summary>
    [SerializeField]
    public struct PointLight
    {
        /// <summary>
        /// the color * the intensity
        /// </summary>
        public Vector4 color;
        /// <summary>
        /// the range of the light
        /// </summary>
        public float range;
        /// <summary>
        /// the position
        /// </summary>
        public Vector3 position;
    }
    /// <summary>
    /// Number of point light accepetd
    /// </summary>
    const int NUMBER_POINT_LIGHT_MAX = 8;

    /// <summary>
    /// Point light container
    /// </summary>
    [SerializeField]
    public PointLight[] pointLights = new PointLight[NUMBER_POINT_LIGHT_MAX];
    /// <summary>
    /// Byte size to send to the shader
    /// </summary>
    const int SIZE_POINT_LIGHT_BYTES = 32;
    ComputeBuffer computeBuffePointLight;

    /// <summary>
    /// Structure of the spotlight send to the shader
    /// </summary>
    [SerializeField]
    public struct SpotLight
    {
        /// <summary>
        /// The color * the intensity
        /// </summary>
        public Vector4 color;
        /// <summary>
        /// The position
        /// </summary>
        public Vector3 position;
        /// <summary>
        /// The normalized direction and the angle
        /// </summary>
        public Vector4 direction;
        /// <summary>
        /// The parameters for the falloff
        /// </summary>
        public Vector4 parameters;
    }
    /// <summary>
    /// Number of spotlights accepted
    /// </summary>
    const int NUMBER_SPOT_LIGHT_MAX = 8;
    [SerializeField]
    public SpotLight[] spotLights = new SpotLight[NUMBER_SPOT_LIGHT_MAX];
    const int SIZE_SPOT_LIGHT_BYTES = 60;
    /// <summary>
    /// Number of light max rendered
    /// </summary>
    const int NUMBER_LIGHTS_MAX = NUMBER_POINT_LIGHT_MAX / 2 + NUMBER_SPOT_LIGHT_MAX / 2;
    /// <summary>
    /// Data from a directional light, direction and color
    /// </summary>
    private Vector4[] directionalLightData = new Vector4[2]; //Limit to one directional light

    ComputeBuffer computeBufferSpotLight;
    //Forward ID shader cache
    private int numberPointLightsID;
    private int numberSpotLightsID;

    /*** Post process definitions***/

    /// <summary>
    /// The mask filled at runtime
    /// </summary>
    private RenderTexture mask;

    /// <summary>
    /// The post process material, to add noise and change the color
    /// </summary>
    private Material postprocessMaterial;
    /// <summary>
    /// Activate/Desactivate postprocess, the mask will not be generated anymore
    /// </summary>
    private bool ARpostProcessing = true;

    /// <summary>
    /// The blurMaterial used to blur the mask
    /// </summary>
    private Material blurMaterial;
    /// <summary>
    /// A custom blit
    /// </summary>
    private Material blitMaterial;
    /// <summary>
    /// A material to convert the stencil into a texture
    /// </summary>
    private Material matStencilToMask;

    /// <summary>
    /// Compose the mask from different textures
    /// </summary>
    private Material matComposeMask;

    /// <summary>
    /// Blend the textures from the ZEDMeshRenderer
    /// </summary>
    private Material blender;

	/// <summary>
	/// View mode
	/// </summary>
	public sl.VIEW_MODE viewMode = sl.VIEW_MODE.VIEW_IMAGE;

	/// <summary>
	/// Side of Rendering (Left == 0 or Right ==1)
	/// </summary>
	private int side = 0;


	/// <summary>
    /// If AR, render the camera into a rendertarget
    /// </summary>
    [HideInInspector]
    private RenderTexture renderTextureTarget;
    public RenderTexture target
    {
        get { return renderTextureTarget; }
    }

    void Awake()
    {
        //Get the current camera and set the aspect 
        mainCamera = GetComponent<Camera>();
        mainCamera.aspect = aspect;


    }

	public void SetPostProcess(bool c)
	{
		ARpostProcessing = c;
	}

    private WindowAspectRatio aspectRatio;

    private void SetUpGI()
    {
        RenderSettings.skybox = null;
        Color c;
        ColorUtility.TryParseHtmlString("#999999", out c);
        RenderSettings.ambientLight = c;
        DynamicGI.UpdateEnvironment();
    }

    private void Start()
    {
        //No environmental lighting per default
        Shader.SetGlobalFloat("_ZEDExposure", -1);
        //Load the materials
        matStencilToMask = new Material(Resources.Load("Materials/PostProcessing/Mat_ZED_Stencil2Mask") as Material);
        matComposeMask = new Material(Resources.Load("Materials/PostProcessing/Mat_ZED_MaskCompositor") as Material);

        //Load and configure the post process
        postprocessMaterial = new Material(Resources.Load("Materials/PostProcessing/Mat_ZED_PostProcessing") as Material);
        postprocessMaterial.SetFloat("_gamma", 1.0f / (0.87f * 0.9f));
        postprocessMaterial.SetFloat("_MinBlack", 15.0f / 255.0f);
        postprocessMaterial.SetInt("_NoiseSize", 2);

        //Configure the weights for the blur
        float[] weights;
        float[] offsets;
        ZEDPostProcessingTools.ComputeWeights(0.3f, out weights, out offsets);

        //Set the blur config to the shader, should be constant
        blurMaterial = new Material(Resources.Load("Materials/PostProcessing/Mat_ZED_Blur") as Material);
        blurMaterial.SetFloatArray("weights", weights);
        blurMaterial.SetFloatArray("offset", offsets);
        blurMaterial.SetTexture("_Mask", mask);


        //Force unity the 16:9 mode
#if UNITY_EDITOR
        UnityEditor.PlayerSettings.SetAspectRatio(UnityEditor.AspectRatio.Aspect16by9, true);
        UnityEditor.PlayerSettings.SetAspectRatio(UnityEditor.AspectRatio.Aspect16by10, false);
        UnityEditor.PlayerSettings.SetAspectRatio(UnityEditor.AspectRatio.Aspect4by3, false);
        UnityEditor.PlayerSettings.SetAspectRatio(UnityEditor.AspectRatio.Aspect5by4, false);
#endif
        CreateRenderTexture();

        //Load the blender for the zedmesher
        blender = new Material(Resources.Load("Materials/SpatialMapping/Mat_ZED_PostProcess_Blend") as Material);

        //Set the bounds larger
        bounds = new Bounds(transform.position, new Vector3(20, 20, 20));

        // If AR REMOVE
        aspectRatio = new WindowAspectRatio(mainCamera);

    }



    void ZEDReady()
    {
        //Add the fader
        gameObject.AddComponent<LoadingFade>();
        zedCamera = sl.ZEDCamera.GetInstance();
		SetTextures(zedCamera,viewMode);
        canvas.SetActive(true);
		canvas.transform.SetParent (mainCamera.transform);
        ConfigureLightAndShadow(mainCamera.actualRenderingPath);

		//Move the plane with the optical centers
		float plane_distance =0.15f;
		Vector4 opticalCenters = zedCamera.ComputeOpticalCenterOffsets(plane_distance);

		if (side==0)
		canvas.transform.localPosition = new Vector3(opticalCenters.x, -1.0f * opticalCenters.y,plane_distance);
		else if (side==1)
		canvas.transform.localPosition = new Vector3(opticalCenters.z, -1.0f * opticalCenters.w,plane_distance);	
	

        //Set the camera parameters and scale the screen
		if (zedCamera.IsCameraReady)
        {
			mainCamera.fieldOfView = zedCamera.VerticalFieldOfView * Mathf.Rad2Deg;
            mainCamera.projectionMatrix = zedCamera.Projection;
            mainCamera.nearClipPlane = 0.1f;
            mainCamera.farClipPlane = 500.0f;
            scale(canvas.gameObject, GetFOVYFromProjectionMatrix(mainCamera.projectionMatrix));
        }
        else
        {
            scale(canvas.gameObject, mainCamera.fieldOfView);
        }   
    }

	void ZEDDisconnected()
	{
		canvas.SetActive(false);
	}


    private void OnEnable()
    {
        SetUpGI();

        meshCanvas = gameObject.transform.GetChild(0).GetComponent<MeshFilter>();
        canvas.SetActive(false);
        ZEDManager.OnZEDReady += ZEDReady;
		ZEDManager.OnZEDDisconnected += ZEDDisconnected;
    }

    private void OnDisable()
    {
        ZEDManager.OnZEDReady -= ZEDReady;
		ZEDManager.OnZEDDisconnected -= ZEDDisconnected;
        canvas.SetActive(false);
    }

 

    //Invisible object to force unity to render shadow map
    GameObject forceShadowObject = null;

    /// <summary>
    /// Configure the canvas to get and light and shadow
    /// </summary>
    /// <param name="renderingPath">The current rendering path used</param>
    private void ConfigureLightAndShadow(RenderingPath renderingPath)
    {
        RenderingPath current = actualRenderingPath;
        actualRenderingPath = renderingPath;

        if (renderingPath == RenderingPath.Forward)
        {
            canvas.SetActive(true);
            SetForward();

        }
        else if (renderingPath == RenderingPath.DeferredShading)
        {
            SetDeferred();
        }
        else
        {
            actualRenderingPath = current;
            Debug.LogError(" [ ZED Plugin ] : The rendering path " + mainCamera.actualRenderingPath.ToString() + " is not compatible with the ZED");
        }
    }

    /// <summary>
    /// Clear the depth buffer used
    /// </summary>
    private void ClearDepthBuffers()
    {
        if (buffer[(int)ZED_RENDERING_MODE.FORWARD] != null)
        {
            buffer[(int)ZED_RENDERING_MODE.FORWARD].Dispose();
            buffer[(int)ZED_RENDERING_MODE.FORWARD] = null;
        }

        if (buffer[(int)ZED_RENDERING_MODE.DEFERRED] != null)
        {
            buffer[(int)ZED_RENDERING_MODE.DEFERRED].Dispose();
            buffer[(int)ZED_RENDERING_MODE.DEFERRED] = null;

        }
    }

    /// <summary>
    /// Configure the materials and buffer in forward mode
    /// </summary>
    private void SetForward()
    {
        ghasShadows = false;


        blitMaterial = new Material(Resources.Load("Materials/PostProcessing/Mat_ZED_Blit") as Material);

        Shader.SetGlobalInt("_HasShadows", 0);

        gameObject.transform.GetChild(0).GetComponent<MeshRenderer>().enabled = true;

        //Set textures to the shader
        matRGB = canvas.GetComponent<Renderer>().material;
        matRGB.SetInt("_isLinear", System.Convert.ToInt32(QualitySettings.activeColorSpace));

        forwardMat = new Material(Resources.Load("Materials/Lighting/Mat_ZED_Forward") as Material);


        // Configure the invisible object
        if (forceShadowObject == null)
        {
            ConfigureForceShadowObject();
        }

        //Set the textures into the materials
        matRGB.SetTexture("_MainTex", textureEye);
        matRGB.SetTexture("_CameraTex", textureEye);
        matRGB.SetTexture("_DepthXYZTex", depth);
        matRGB.SetTexture("_NormalsTex", normals);


        forwardMat.SetTexture("_MainTex", textureEye);
        forwardMat.SetTexture("_DepthXYZTex", depth);

        //Clear the buffers
        if (buffer[(int)ZED_RENDERING_MODE.FORWARD] != null)
            mainCamera.RemoveCommandBuffer(CameraEvent.BeforeDepthTexture, buffer[(int)ZED_RENDERING_MODE.FORWARD]);

        if (buffer[(int)ZED_RENDERING_MODE.DEFERRED] != null)
            mainCamera.RemoveCommandBuffer(CameraEvent.AfterGBuffer, buffer[(int)ZED_RENDERING_MODE.DEFERRED]);
        ClearDepthBuffers();

        if (postProcessBuffer[(int)ZED_RENDERING_MODE.DEFERRED] != null)
            mainCamera.RemoveCommandBuffer(CameraEvent.AfterFinalPass, postProcessBuffer[(int)ZED_RENDERING_MODE.DEFERRED]);

        if (postProcessBuffer[(int)ZED_RENDERING_MODE.DEFERRED] != null)
        {
            postProcessBuffer[(int)ZED_RENDERING_MODE.DEFERRED].Dispose();
            postProcessBuffer[(int)ZED_RENDERING_MODE.DEFERRED] = null;
        }

        //Set the depth buffer
        buffer[(int)ZED_RENDERING_MODE.FORWARD] = new CommandBuffer();
        buffer[(int)ZED_RENDERING_MODE.FORWARD].name = "ZED_DEPTH";
        buffer[(int)ZED_RENDERING_MODE.FORWARD].SetRenderTarget(BuiltinRenderTextureType.CurrentActive);
        buffer[(int)ZED_RENDERING_MODE.FORWARD].DrawMesh(meshCanvas.mesh, gameObject.transform.GetChild(0).transform.localToWorldMatrix, forwardMat);

        if (mask == null || !mask.IsCreated())
        {
            mask = new RenderTexture(Screen.width, Screen.height, 0, RenderTextureFormat.R8);
        }

        //Set the post process
        postprocessMaterial.SetTexture("ZEDMaskPostProcess", mask);
        postprocessMaterial.SetTexture("ZEDTex", textureEye);

        postProcessBuffer[(int)ZED_RENDERING_MODE.FORWARD] = new CommandBuffer();
        postProcessBuffer[(int)ZED_RENDERING_MODE.FORWARD].name = "ZED_FORWARD_POSTPROCESS";
        postProcessBuffer[(int)ZED_RENDERING_MODE.FORWARD].Blit(BuiltinRenderTextureType.CameraTarget, mask, blitMaterial, 0);
        postProcessBuffer[(int)ZED_RENDERING_MODE.FORWARD].SetGlobalTexture("_ZEDMaskVirtual", mask);

        mainCamera.RemoveCommandBuffer(CameraEvent.AfterForwardAlpha, postProcessBuffer[(int)ZED_RENDERING_MODE.FORWARD]);
        mainCamera.AddCommandBuffer(CameraEvent.AfterForwardAlpha, postProcessBuffer[(int)ZED_RENDERING_MODE.FORWARD]);

        //Configure the light containers
        if (computeBuffePointLight == null)
        {
            computeBuffePointLight = new ComputeBuffer(NUMBER_POINT_LIGHT_MAX, SIZE_POINT_LIGHT_BYTES);
            computeBuffePointLight.SetData(pointLights);

            matRGB.SetBuffer("pointLights", computeBuffePointLight);
        }

        if (computeBufferSpotLight == null)
        {
            computeBufferSpotLight = new ComputeBuffer(NUMBER_SPOT_LIGHT_MAX, SIZE_SPOT_LIGHT_BYTES);
            computeBufferSpotLight.SetData(spotLights);
            matRGB.SetBuffer("spotLights", computeBufferSpotLight);
        }

        //Register the properties ID to improve the speed
        numberPointLightsID = Shader.PropertyToID("numberPointLights");
        numberSpotLightsID = Shader.PropertyToID("numberSpotLights");

    }

    /// <summary>
    /// Configure the materials and buffer for the deferred mode
    /// </summary>
    private void SetDeferred()
    {
        //Disable MSSA not supported with deferred
#if UNITY_5_6_OR_NEWER
        mainCamera.allowMSAA = false;
#endif


        ghasShadows = false;
        deferredMat = new Material(Resources.Load("Materials/Lighting/Mat_ZED_Deferred") as Material);
        blitMaterial = new Material(Resources.Load("Materials/PostProcessing/Mat_ZED_Blit") as Material);

        //Sets the custom shader for the deferred pipeline
        GraphicsSettings.SetCustomShader(BuiltinShaderType.DeferredShading, (Resources.Load("Materials/Lighting/Mat_ZED_Deferred_Lighting") as Material).shader);

        deferredMat.SetMatrix("_Model", canvas.transform.localToWorldMatrix.transpose);
        deferredMat.SetMatrix("_Projection", mainCamera.projectionMatrix);

        deferredMat.SetTexture("_MainTex", textureEye);
        deferredMat.SetTexture("_DepthXYZTex", depth);
        deferredMat.SetTexture("_NormalsTex", normals);


        //clear the buffers
        if (buffer[(int)ZED_RENDERING_MODE.FORWARD] != null)
            mainCamera.RemoveCommandBuffer(CameraEvent.BeforeDepthTexture, buffer[(int)ZED_RENDERING_MODE.FORWARD]);

        if (buffer[(int)ZED_RENDERING_MODE.DEFERRED] != null)
            mainCamera.RemoveCommandBuffer(CameraEvent.AfterGBuffer, buffer[(int)ZED_RENDERING_MODE.DEFERRED]);

        if (postProcessBuffer[(int)ZED_RENDERING_MODE.FORWARD] != null)
            mainCamera.RemoveCommandBuffer(CameraEvent.AfterForwardAlpha, postProcessBuffer[(int)ZED_RENDERING_MODE.FORWARD]);
        if (postProcessBuffer[(int)ZED_RENDERING_MODE.FORWARD] != null)
        {
            postProcessBuffer[(int)ZED_RENDERING_MODE.FORWARD].Dispose();
            postProcessBuffer[(int)ZED_RENDERING_MODE.FORWARD] = null;
        }

        ClearDepthBuffers();

        //Set the depths buffer, the buffer will be changed if the camera allow HDR
        buffer[(int)ZED_RENDERING_MODE.DEFERRED] = new CommandBuffer();
        buffer[(int)ZED_RENDERING_MODE.DEFERRED].name = "ZED_DEPTH";

        if (mainCamera.allowHDR)
        {
            RenderTargetIdentifier[] mrt = { BuiltinRenderTextureType.GBuffer0, BuiltinRenderTextureType.GBuffer1, BuiltinRenderTextureType.GBuffer2, BuiltinRenderTextureType.CameraTarget };
            buffer[(int)ZED_RENDERING_MODE.DEFERRED].SetRenderTarget(mrt, BuiltinRenderTextureType.CameraTarget);
        }
        else
        {
            RenderTargetIdentifier[] mrt = { BuiltinRenderTextureType.GBuffer0, BuiltinRenderTextureType.GBuffer1, BuiltinRenderTextureType.GBuffer2, BuiltinRenderTextureType.GBuffer3 };
            buffer[(int)ZED_RENDERING_MODE.DEFERRED].SetRenderTarget(mrt, BuiltinRenderTextureType.CameraTarget);
        }
        buffer[(int)ZED_RENDERING_MODE.DEFERRED].DrawMesh(meshCanvas.mesh, gameObject.transform.GetChild(0).transform.localToWorldMatrix, deferredMat);

        if (mask == null || !mask.IsCreated())
        {
            mask = new RenderTexture(Screen.width, Screen.height, 0, RenderTextureFormat.R8);
        }
        //Set the post process buffer
        postProcessBuffer[(int)ZED_RENDERING_MODE.DEFERRED] = new CommandBuffer();
        postProcessBuffer[(int)ZED_RENDERING_MODE.DEFERRED].name = "ZED_FORWARD_POSTPROCESS";
        postProcessBuffer[(int)ZED_RENDERING_MODE.DEFERRED].Blit(BuiltinRenderTextureType.GBuffer0, mask, blitMaterial, 0);
        postProcessBuffer[(int)ZED_RENDERING_MODE.DEFERRED].SetGlobalTexture("_ZEDMaskVirtual", mask);
        postprocessMaterial.SetTexture("ZEDMaskPostProcess", mask);
        postprocessMaterial.SetTexture("ZEDTex", textureEye);



        mainCamera.AddCommandBuffer(CameraEvent.AfterGBuffer, buffer[(int)ZED_RENDERING_MODE.DEFERRED]);
        mainCamera.AddCommandBuffer(CameraEvent.AfterFinalPass, postProcessBuffer[(int)ZED_RENDERING_MODE.DEFERRED]);

        //Congigure the invisible object
        if (forceShadowObject == null)
        {
            ConfigureForceShadowObject();
        }
        transform.GetChild(0).GetComponent<MeshRenderer>().enabled = false;

    }

    private void ConfigureForceShadowObject()
    {
        forceShadowObject = GameObject.CreatePrimitive(PrimitiveType.Quad);
        forceShadowObject.name = "ZED_FORCE_SHADOW";
        forceShadowObject.transform.parent = transform;

        forceShadowObject.transform.localPosition = new Vector3(0, 0, mainCamera.nearClipPlane);
        forceShadowObject.GetComponent<MeshRenderer>().sharedMaterial = Resources.Load("Materials/Lighting/Mat_ZED_Hide") as Material;
        Destroy(forceShadowObject.GetComponent<MeshCollider>());
        forceShadowObject.hideFlags = HideFlags.HideAndDontSave;
    }

    //Bounds around the camera, it filters which camera are taken in forward mode 
    private Bounds bounds;
    private void CreateRenderTexture()
    {
        transform.localRotation = Quaternion.identity;
        transform.localPosition = new Vector3(0, 0, 0);
        if (mainCamera.stereoTargetEye != StereoTargetEyeMask.None)
        {
			if (zedCamera != null && zedCamera.IsCameraReady)
            {
                renderTextureTarget = new RenderTexture(zedCamera.ImageWidth, zedCamera.ImageHeight, 24, RenderTextureFormat.ARGB32);
                mainCamera.targetTexture = renderTextureTarget;
            }
            else
            {
                renderTextureTarget = new RenderTexture(Screen.width, Screen.height, 24, RenderTextureFormat.ARGB32);
                mainCamera.targetTexture = renderTextureTarget;
            }
        }
    }

    /// <summary>
    /// Create and set the textures
    /// </summary>
    /// <param name="zedCamera"></param>
	private void SetTextures(sl.ZEDCamera zedCamera,sl.VIEW_MODE view_mode)
    {
        float baseline = zedCamera.Baseline;
        canvas.transform.localRotation = Quaternion.identity;
        canvas.transform.localPosition = new Vector3(0, 0, 0);

        if (StereoTargetEyeMask.Left == mainCamera.stereoTargetEye)
        {
			side = 0;
			if (zedCamera != null && zedCamera.IsCameraReady)
            {
                renderTextureTarget = new RenderTexture(zedCamera.ImageWidth, zedCamera.ImageHeight, 24, RenderTextureFormat.ARGB32);
                mainCamera.targetTexture = renderTextureTarget;
            }

			switch (view_mode) {
			case sl.VIEW_MODE.VIEW_IMAGE: 
				textureEye = zedCamera.CreateTextureImageType (sl.VIEW.LEFT);
				break;
			case sl.VIEW_MODE.VIEW_DEPTH: 
				textureEye = zedCamera.CreateTextureImageType (sl.VIEW.DEPTH);
				break;
			case sl.VIEW_MODE.VIEW_NORMALS: 
				textureEye = zedCamera.CreateTextureImageType (sl.VIEW.NORMALS);
				break;
			}
           
            normals = zedCamera.CreateTextureMeasureType(sl.MEASURE.NORMALS, resolution);
            depth = zedCamera.CreateTextureMeasureType(sl.MEASURE.DEPTH, resolution);

        }
        else if (StereoTargetEyeMask.Right == mainCamera.stereoTargetEye)
        {
			side = 1;
			if (zedCamera != null && zedCamera.IsCameraReady)
            {
                renderTextureTarget = new RenderTexture(zedCamera.ImageWidth, zedCamera.ImageHeight, 24, RenderTextureFormat.ARGB32);
                mainCamera.targetTexture = renderTextureTarget;
            }

			switch (view_mode) {
			case sl.VIEW_MODE.VIEW_IMAGE: 
				textureEye = zedCamera.CreateTextureImageType (sl.VIEW.RIGHT);
				break;
			case sl.VIEW_MODE.VIEW_DEPTH: 
				textureEye = zedCamera.CreateTextureImageType (sl.VIEW.DEPTH_RIGHT);
				break;
			case sl.VIEW_MODE.VIEW_NORMALS: 
				textureEye = zedCamera.CreateTextureImageType (sl.VIEW.NORMALS_RIGHT);
				break;
			}
            normals = zedCamera.CreateTextureMeasureType(sl.MEASURE.NORMALS_RIGHT, resolution);
            depth = zedCamera.CreateTextureMeasureType(sl.MEASURE.DEPTH_RIGHT, resolution);

        }
        else
        {
			side = 0;
			switch (view_mode) {
			case sl.VIEW_MODE.VIEW_IMAGE: 
				textureEye = zedCamera.CreateTextureImageType (sl.VIEW.LEFT);
				break;
			case sl.VIEW_MODE.VIEW_DEPTH: 
				textureEye = zedCamera.CreateTextureImageType (sl.VIEW.DEPTH);
				break;
			case sl.VIEW_MODE.VIEW_NORMALS: 
				textureEye = zedCamera.CreateTextureImageType (sl.VIEW.NORMALS);
				break;
			}
            normals = zedCamera.CreateTextureMeasureType(sl.MEASURE.NORMALS, resolution);
            depth = zedCamera.CreateTextureMeasureType(sl.MEASURE.DEPTH, resolution);

        }
    }

    /// <summary>
    /// To enable/disable keyword for the material of the first pass
    /// </summary>
    /// <param name="enable"></param>
    /// <param name="name"></param>
    /// <returns></returns>
    public bool ManageKeyWordForwardMat(bool enable, string name)
    {
        if (forwardMat)
        {
            if (enable)
            {
                forwardMat.EnableKeyword(name);
            }
            else
            {
                forwardMat.DisableKeyword(name);
            }
            return true;

        }
        
         return false;
    }

	public bool ManageKeyWordDefferedMat(bool enable, string name)
	{
		if (deferredMat)
		{
			if (enable)
			{
				deferredMat.EnableKeyword(name);
			}
			else
			{
				deferredMat.DisableKeyword(name);
			}
			return true;

		}

		return false;
	}

	public bool ManageKeyWordPipe(bool enable, string name)
	{
		if (matRGB)
		{
			if (enable)
			{
				matRGB.EnableKeyword(name);
			}
			else
			{
				matRGB.DisableKeyword(name);
			}
			return true;

		}

		return false;
	}

    /// <summary>
    /// Variables to get some informations about the lights
    /// </summary>
    [HideInInspector]
    public int numberPointLights;
    [HideInInspector]
    public int numberSpotLights;
    bool ghasShadows = false;

    /// <summary>
    /// Update the lights information and send them to the shader
    /// </summary>
    void UpdateLights()
    {
        bool hasShadows = false;

        int pointLightIndex = 0;
        int spotLighIndex = 0;
        bounds.center = transform.position;

        foreach (ZEDLight zed_light in ZEDLight.s_lights)
        {
            Light light = zed_light.cachedLight;

            if (light.type == LightType.Directional || Vector3.Distance(bounds.center, light.transform.position) <  (light.range + bounds.extents.x))
            {

                //Desactivate all shadows from point light and spot light, they are not currently supported
                if (light.type != LightType.Directional)
                {
                    light.shadows = LightShadows.None;
                }
                if (zed_light.IsEnabled() && ((pointLightIndex + spotLighIndex) < NUMBER_LIGHTS_MAX || light.type == LightType.Directional))
                {
                    if (light.type == LightType.Point)
                    {

                        if (pointLightIndex < NUMBER_POINT_LIGHT_MAX)
                        {
                            pointLights[pointLightIndex].color = light.color * light.intensity;
                            pointLights[pointLightIndex].position = light.gameObject.transform.position;
                            pointLights[pointLightIndex].range = light.range;

                            pointLightIndex++;
                        }

                    }

                    else if (light.type == LightType.Spot)
                    {

                        if (spotLighIndex < NUMBER_SPOT_LIGHT_MAX)
                        {
                            spotLights[spotLighIndex].color = light.color * light.intensity;
                            spotLights[spotLighIndex].position = light.gameObject.transform.position;
                            spotLights[spotLighIndex].direction = new Vector4(light.gameObject.transform.forward.normalized.x, light.gameObject.transform.forward.normalized.y, light.gameObject.transform.forward.normalized.z, Mathf.Cos((light.spotAngle / 2.0f) * Mathf.Deg2Rad));
                            spotLights[spotLighIndex].parameters = new Vector4(light.spotAngle, light.intensity, 1.0f / light.range, zed_light.interiorCone);
                            spotLighIndex++;
                        }
                    }
                    else if (light.type == LightType.Directional)
                    {
                        hasShadows = light.shadows != LightShadows.None && QualitySettings.shadows != ShadowQuality.Disable;
                        directionalLightData[0] = new Vector4(light.gameObject.transform.forward.normalized.x, light.gameObject.transform.forward.normalized.y, light.gameObject.transform.forward.normalized.z, 0);
                        directionalLightData[1] = light.color * light.intensity;
                        // Copy the shadows from the directional light, If not no shadows in transparent mode
                        if (light.commandBufferCount == 0)
                        {
                            forwardMat.SetInt("_HasShadows", System.Convert.ToInt32(light.shadows != LightShadows.None));

                            // Copy the shadows from the directional light, If not no shadows in transparent mode
                            if (light.commandBufferCount == 0)
                            {
                                CommandBuffer lightBuffer = new CommandBuffer();
                                lightBuffer.name = "ZED_Copy_ShadowMap";
                                lightBuffer.SetGlobalTexture("_DirectionalShadowMap", BuiltinRenderTextureType.CurrentActive);

                                light.AddCommandBuffer(LightEvent.AfterScreenspaceMask, lightBuffer);
                            }

                        }
                    }
                }
            }
        }
        //Upload the new Data
        if (computeBuffePointLight != null)
        {
            computeBuffePointLight.SetData(pointLights);
        }
        if (computeBufferSpotLight != null)
        {
            computeBufferSpotLight.SetData(spotLights);
        }

        numberPointLights = pointLightIndex;
        numberSpotLights = spotLighIndex;

        if (matRGB != null)
        {
            //Add the command buffer to get shadows only if a directional light creates shadows
            if (hasShadows != ghasShadows)
            {
                ghasShadows = hasShadows;
                Shader.SetGlobalInt("_HasShadows", System.Convert.ToInt32(ghasShadows));
                mainCamera.RemoveCommandBuffer(CameraEvent.BeforeDepthTexture, buffer[(int)ZED_RENDERING_MODE.FORWARD]);
                if (hasShadows)
                {
                    mainCamera.AddCommandBuffer(CameraEvent.BeforeDepthTexture, buffer[(int)ZED_RENDERING_MODE.FORWARD]);
                }

            }
            //Send the number of pointLights/SpotLights to the shader
            matRGB.SetInt(numberPointLightsID, pointLightIndex);
            matRGB.SetInt(numberSpotLightsID, spotLighIndex);
        }
        matRGB.SetVectorArray("ZED_directionalLight", directionalLightData);
    }


    /// <summary>
    /// Get back the FOV from the Projection matrix, to bypass a round number
    /// </summary>
    /// <param name="projection"></param>
    /// <returns></returns>
    float GetFOVYFromProjectionMatrix(Matrix4x4 projection)
    {
        return Mathf.Atan(1 / projection[1, 1]) * 2.0f;
    }
	float GetFOVXFromProjectionMatrix(Matrix4x4 projection)
	{
		return Mathf.Atan(1 / projection[0, 0]) * 2.0f;
	}





    /// <summary>
    /// Scale a screen in front of the camera, where all the textures will be rendered.
    /// </summary>
    /// <param name="screen"></param>
    /// <param name="fov"></param>
	private void scale(GameObject screen, float fov)
    {
		float height = Mathf.Tan(0.5f * fov) * Vector3.Distance(screen.transform.localPosition, Vector3.zero) * 2;
		screen.transform.localScale = new Vector3((height*aspect), height, 1);
    }

	private void scaleXY(GameObject screen, float fovH,float fovV)
	{
		float height = Mathf.Tan(0.5f * fovV) * Vector3.Distance(screen.transform.localPosition, Vector3.zero) * 2;
		float width = Mathf.Tan(0.5f * fovH) * Vector3.Distance(screen.transform.localPosition,Vector3.zero) * 2;
		screen.transform.localScale = new Vector3(width, height, 1);
	}


    void OnApplicationQuit()
    {

        if (computeBuffePointLight != null)
        {
            computeBuffePointLight.Release();
        }

        if (computeBufferSpotLight != null)
        {
            computeBufferSpotLight.Release();
        }

        if (mask != null)
        {
            mask.Release();
        }
    }

    void Update()
    {
        if(aspectRatio != null)
        {
            aspectRatio.Update();
        }

        if (actualRenderingPath == RenderingPath.Forward)
        {
            bounds.center = transform.position;
            UpdateLights();
        }

#if UNITY_EDITOR
        if (actualRenderingPath != RenderingPath.VertexLit && mainCamera.actualRenderingPath != actualRenderingPath)
        {
            ConfigureLightAndShadow(mainCamera.actualRenderingPath);
        }
#endif


    }


    /// <summary>
    /// Used by the ZEDMeshRenderer for the spatial mapping
    /// </summary>
    private RenderTexture textureSpatialMapping;
    public void SetTextureSpatialMapping(RenderTexture texture)
    {
        textureSpatialMapping = texture;
        blender.SetTexture("_ZEDMeshTex", textureSpatialMapping);
    }

    /// <summary>
    /// Where the post process occurs
    /// </summary>
    /// <param name="source"></param>
    /// <param name="destination"></param>
    private void OnRenderImage(RenderTexture source, RenderTexture destination)
    {
        if (ZEDSpatialMapping.display)
        {
            RenderTexture tmpSource = RenderTexture.GetTemporary(source.width, source.height, source.depth, source.format, RenderTextureReadWrite.sRGB);
            Graphics.Blit(source, tmpSource);
            blender.SetInt("_IsTextured", 0);
            Graphics.Blit(tmpSource, destination, blender);
            RenderTexture.ReleaseTemporary(tmpSource);
        }

        else
        {
            //Blit issue under opengl in standalone application. Post process is desactivated
			if (ARpostProcessing && mask != null && zedCamera.IsCameraReady)
            {

                if (actualRenderingPath == RenderingPath.DeferredShading)
                {

                    RenderTexture bluredMask = RenderTexture.GetTemporary(mask.width, mask.height, mask.depth, mask.format);

                    RenderTexture buffer = RenderTexture.GetTemporary(source.width, source.height, 24);

                    Graphics.SetRenderTarget(buffer);
                    GL.Clear(false, true, new Color(0, 0, 0, 0));   // clear the full RT

                    //To keep the stencil in post process
                    Graphics.SetRenderTarget(buffer.colorBuffer, source.depthBuffer);
                    Graphics.Blit(source, matStencilToMask);

                    //Compose the second mask get in the forward pass. The shader should set the stencil to 148
                    Graphics.Blit(mask, bluredMask);
                    matComposeMask.SetTexture("_Mask", bluredMask);
                    Graphics.Blit(buffer, mask, matComposeMask);

                    ApplyPostProcess(source, destination, bluredMask);

                    RenderTexture.ReleaseTemporary(buffer);
                    RenderTexture.ReleaseTemporary(bluredMask);
                }
                else
                {
                    RenderTexture bluredMask = RenderTexture.GetTemporary(mask.width, mask.height, mask.depth, mask.format);
                    ApplyPostProcess(source, destination, bluredMask);
                    RenderTexture.ReleaseTemporary(bluredMask);
                }
            }

            else
            {
                Graphics.Blit(source, destination);
            }
        }
    }

    /// <summary>
    /// Post process pipeline
    /// </summary>
    /// <param name="source"></param>
    /// <param name="destination"></param>
    /// <param name="bluredMask"></param>
    private void ApplyPostProcess(RenderTexture source, RenderTexture destination, RenderTexture bluredMask)
    {
        RenderTexture tempDestination = RenderTexture.GetTemporary(source.width, source.height, source.depth, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Default);

        Graphics.Blit(source, tempDestination, postprocessMaterial);
        ZEDPostProcessingTools.Blur(mask, bluredMask, blurMaterial, 3, 1, 1);

        blurMaterial.SetTexture("_Mask", bluredMask);
        ZEDPostProcessingTools.Blur(tempDestination, destination, blurMaterial, 2, 1, 1);
        mask.SetGlobalShaderProperty("_ZEDMaskVirtual");
        RenderTexture.ReleaseTemporary(tempDestination);

    }

    public class WindowAspectRatio
    {
        /// <summary>
        /// Current screen width
        /// </summary>
        private int ScreenSizeX = 0;

        /// <summary>
        /// Current screen height
        /// </summary>
        private int ScreenSizeY = 0;

        /// <summary>
        /// Camera to set to 16:9
        /// </summary>
        private Camera cam;

        /// <summary>
        /// Aspect ratio targeted
        /// </summary>
        private const float TARGET_ASPECT = 16.0f / 9.0f;


        public WindowAspectRatio(Camera camera)
        {
            cam = camera;
            RescaleCamera();
            CreateCamera();
        }

        /// <summary>
        /// Create a custom camera to render black bars
        /// </summary>
        /// <returns></returns>
        private GameObject CreateCamera()
        {
            GameObject o = new GameObject("CameraBlackBackground");
            Camera cam = o.AddComponent<Camera>();
            cam.backgroundColor = Color.black;
            cam.cullingMask = 0;
            cam.clearFlags = CameraClearFlags.SolidColor;
            cam.depth = -int.MaxValue;
            cam.useOcclusionCulling = false;
#if UNITY_5_6_OR_NEWER
            cam.allowHDR = false;
            cam.allowMSAA = false;
#endif
            cam.stereoTargetEye = StereoTargetEyeMask.None;
            cam.renderingPath = RenderingPath.Forward;
            o.hideFlags = HideFlags.HideAndDontSave;
            return o;

        }



        /// <summary>
        /// Rescale the view port of the current camera
        /// </summary>
        private void RescaleCamera()
        {
            //If no change, then return
            if (Screen.width == ScreenSizeX && Screen.height == ScreenSizeY) return;

            float windowaspect = (float)Screen.width / (float)Screen.height;
            float scaleheight = windowaspect / TARGET_ASPECT;

            if (scaleheight < 1.0f)
            {
                Rect rect = cam.rect;

                rect.width = 1.0f;
                rect.height = scaleheight;
                rect.x = 0;
                rect.y = (1.0f - scaleheight) / 2.0f;

                cam.rect = rect;
            }
            else // add pillarbox
            {
                float scalewidth = 1.0f / scaleheight;

                Rect rect = cam.rect;

                rect.width = scalewidth;
                rect.height = 1.0f;
                rect.x = (1.0f - scalewidth) / 2.0f;
                rect.y = 0;

                cam.rect = rect;
            }

            ScreenSizeX = Screen.width;
            ScreenSizeY = Screen.height;
        }


        public void Update()
        {
            RescaleCamera();
        }
    }

}




